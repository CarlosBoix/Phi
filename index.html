<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>φ · coherence field</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;1,300;1,400&family=DM+Mono:wght@300;400&display=swap');

:root {
  --bg: #080808;
  --gold: #c8a84b;
  --phosphor: #e8e0cc;
  --pdim: rgba(232,224,204,0.3);
  --lock: #8b3a2a;
  --noise: #2a4a7a;
  --ribbon: #c8a84b;
  --edge: #8b5a2a;
  --breath: #d4b87a;
  --safe-bottom: env(safe-area-inset-bottom, 0px);
}

* { 
  margin:0; 
  padding:0; 
  box-sizing:border-box; 
  -webkit-tap-highlight-color:transparent; 
}

html, body {
  width:100%;
  min-height:100vh;
  min-height:-webkit-fill-available;
  background:var(--bg);
  color:var(--phosphor);
  font-family:'DM Mono', monospace;
  overflow-x:hidden;
  overflow-y:auto;
  -webkit-overflow-scrolling:touch;
  touch-action:pan-y pinch-zoom;
  user-select:none;
}

#app {
  width:100%;
  min-height:100vh;
  min-height:-webkit-fill-available;
  display:flex; 
  flex-direction:column;
  align-items:center; 
  justify-content:space-between;
  position:relative;
  padding-bottom:var(--safe-bottom);
}

#bg-canvas { 
  position:fixed; 
  top:0; 
  left:0; 
  width:100%; 
  height:100%; 
  z-index:0;
  pointer-events:none;
}

/* TOP */
#top {
  position:relative; 
  z-index:2;
  width:100%; 
  padding:18px 24px 0;
  display:flex; 
  justify-content:space-between; 
  align-items:flex-start;
}
#phi-mark {
  font-family:'Cormorant Garamond', serif;
  font-size:22px; 
  font-weight:300;
  color:var(--gold); 
  letter-spacing:0.05em;
}
#time-display {
  font-size:10px; 
  color:var(--pdim);
  letter-spacing:0.2em; 
  text-align:right; 
  line-height:1.6;
}

/* CENTRE */
#centre {
  position:relative; 
  z-index:2;
  display:flex; 
  flex-direction:column;
  align-items:center; 
  justify-content:center;
  flex:1; 
  width:100%;
  padding:16px 0;
}
#ring-wrap {
  position:relative;
  width:min(72vw,320px); 
  height:min(72vw,320px);
}
#ring-canvas {
  position:absolute; 
  top:0; 
  left:0; 
  width:100%; 
  height:100%;
}
#centre-text {
  position:absolute; 
  top:50%; 
  left:50%;
  transform:translate(-50%,-50%);
  text-align:center; 
  pointer-events:none;
}
#regime-word {
  font-family:'Cormorant Garamond', serif;
  font-size:clamp(26px,8vw,40px); 
  font-weight:300; 
  font-style:italic;
  letter-spacing:0.08em; 
  color:var(--gold);
  transition:color 1.5s; 
  line-height:1;
}
#cv-num { 
  font-size:11px; 
  color:var(--pdim); 
  letter-spacing:0.25em; 
  margin-top:8px; 
}
#persist-line { 
  font-size:9px; 
  color:var(--pdim); 
  letter-spacing:0.2em; 
  margin-top:4px; 
  opacity:0.6; 
}

/* BOTTOM */
#bottom {
  position:relative; 
  z-index:2;
  width:100%; 
  padding:0 20px 20px;
}

/* TRACE */
#trace-wrap { 
  width:100%; 
  height:48px; 
  margin-bottom:12px; 
  position:relative; 
}
#trace-label { 
  position:absolute; 
  top:2px; 
  left:0; 
  font-size:7px; 
  letter-spacing:0.25em; 
  color:rgba(255,255,255,0.1); 
  text-transform:uppercase; 
}
#trace-canvas { 
  width:100%; 
  height:100%; 
  display:block; 
}

/* TERNARY BAR */
#ternary-bar { 
  width:100%; 
  height:12px; 
  display:flex; 
  gap:1px; 
  margin-bottom:12px; 
}
.tseg { 
  flex:1; 
  border-radius:1px; 
  transition:background 0.15s; 
  background:rgba(255,255,255,0.03); 
}

/* BAND STRIP */
#band-label { 
  font-size:8px; 
  letter-spacing:0.3em; 
  color:var(--pdim); 
  text-transform:uppercase; 
  margin-bottom:5px; 
  text-align:center; 
  opacity:0.5; 
}
#band-track { 
  width:100%; 
  height:2px; 
  background:rgba(255,255,255,0.05); 
  position:relative; 
  border-radius:1px; 
  margin-bottom:2px; 
}
#band-fill { 
  height:100%; 
  border-radius:1px; 
  background:var(--gold); 
  position:absolute; 
  left:0; 
  top:0; 
  transition:width 0.4s, background 0.8s; 
}
#band-ticks { 
  position:relative; 
  height:14px; 
}
.btick { 
  position:absolute; 
  top:0; 
  width:1px; 
  height:5px; 
  background:rgba(255,255,255,0.1); 
  transform:translateX(-50%); 
}
.blabel { 
  position:absolute; 
  top:6px; 
  font-size:7px; 
  color:rgba(255,255,255,0.15); 
  transform:translateX(-50%); 
  white-space:nowrap; 
}

/* STATS */
#stats {
  display:grid; 
  grid-template-columns:1fr 1fr 1fr;
  gap:1px; 
  background:rgba(255,255,255,0.04);
  border:1px solid rgba(255,255,255,0.05); 
  border-radius:2px;
  overflow:hidden; 
  margin-bottom:10px;
}
.sc { 
  background:var(--bg); 
  padding:9px 0; 
  text-align:center; 
}
.sn { 
  font-size:7px; 
  letter-spacing:0.25em; 
  color:rgba(255,255,255,0.2); 
  text-transform:uppercase; 
  display:block; 
  margin-bottom:3px; 
}
.sv { 
  font-size:13px; 
  font-weight:300; 
  color:var(--phosphor); 
  letter-spacing:0.05em; 
  transition:color 0.8s; 
}

/* BASELINE + TRANSITION */
#meta-line { 
  text-align:center; 
  font-size:9px; 
  letter-spacing:0.22em; 
  color:var(--gold); 
  margin-bottom:2px; 
  height:13px; 
  transition:opacity 0.8s; 
}
#trans-line { 
  text-align:center; 
  font-size:8px; 
  letter-spacing:0.2em; 
  color:var(--pdim); 
  margin-bottom:8px; 
  height:12px; 
}

/* TYPING */
#type-wrap { 
  width:100%; 
  margin-bottom:10px; 
  position:relative; 
}
#type-label { 
  position:absolute; 
  top:-13px; 
  left:0; 
  font-size:7px; 
  letter-spacing:0.3em; 
  color:rgba(255,255,255,0.12); 
  text-transform:uppercase; 
}
#type-input {
  width:100%; 
  background:rgba(255,255,255,0.03);
  border:1px solid rgba(255,255,255,0.07); 
  border-radius:2px;
  padding:9px 12px; 
  font-family:'DM Mono',monospace;
  font-size:12px; 
  font-weight:300; 
  color:var(--phosphor);
  letter-spacing:0.08em; 
  outline:none; 
  caret-color:var(--gold);
  height:36px; 
  transition:border-color 0.5s;
  -webkit-appearance:none;
}
#type-input::placeholder { 
  color:rgba(255,255,255,0.1); 
  font-style:italic; 
}
#type-input:focus { 
  border-color:rgba(200,168,75,0.3); 
}

/* EXPORT */
#export-btn {
  background:none; 
  border:1px solid rgba(200,168,75,0.2);
  color:rgba(200,168,75,0.5); 
  font-family:'DM Mono',monospace;
  font-size:9px; 
  letter-spacing:0.3em; 
  text-transform:uppercase;
  padding:12px 16px; 
  border-radius:2px; 
  cursor:pointer;
  width:100%; 
  transition:border-color 0.3s, color 0.3s; 
  margin-bottom:8px;
  -webkit-touch-callout:none;
}
#export-btn:active { 
  border-color:rgba(200,168,75,0.7); 
  color:rgba(200,168,75,1); 
  background:rgba(200,168,75,0.05);
}

/* PROMPT */
#prompt { 
  text-align:center; 
  font-family:'Cormorant Garamond',serif; 
  font-size:13px; 
  font-style:italic; 
  color:rgba(200,168,75,0.3); 
  letter-spacing:0.1em; 
  transition:opacity 1s; 
}

/* MOTION PERMISSION BUTTON */
#motion-permission {
  position:fixed;
  bottom:20px;
  left:20px;
  right:20px;
  z-index:100;
  background:var(--bg);
  border:1px solid var(--gold);
  color:var(--gold);
  font-family:'DM Mono',monospace;
  font-size:12px;
  letter-spacing:0.2em;
  padding:16px;
  border-radius:4px;
  text-align:center;
  backdrop-filter:blur(8px);
  -webkit-backdrop-filter:blur(8px);
  background:rgba(8,8,8,0.9);
  box-shadow:0 4px 20px rgba(0,0,0,0.5);
  cursor:pointer;
  transition:opacity 0.3s;
}
#motion-permission:active {
  background:rgba(200,168,75,0.2);
}

/* TOUCH HINT */
#touch-hint {
  position:fixed;
  top:20px;
  left:50%;
  transform:translateX(-50%);
  background:rgba(200,168,75,0.1);
  border:1px solid rgba(200,168,75,0.3);
  color:var(--gold);
  font-size:9px;
  padding:8px 16px;
  border-radius:20px;
  letter-spacing:0.2em;
  z-index:50;
  backdrop-filter:blur(4px);
  -webkit-backdrop-filter:blur(4px);
  pointer-events:none;
  opacity:0;
  transition:opacity 1s;
  white-space:nowrap;
}

/* CALIBRATING */
#calibrating {
  position:fixed; 
  top:0; 
  left:0; 
  right:0; 
  bottom:0; 
  z-index:10;
  background:var(--bg); 
  display:flex; 
  flex-direction:column;
  align-items:center; 
  justify-content:center; 
  gap:22px;
  transition:opacity 1.5s;
  padding:0 20px;
}
#cal-phi {
  font-family:'Cormorant Garamond',serif; 
  font-size:min(72px,20vw); 
  font-weight:300;
  color:var(--gold); 
  opacity:0; 
  animation:fi 1.2s ease forwards; 
  letter-spacing:0.1em;
}
#cal-text {
  font-size:clamp(8px,3vw,10px); 
  letter-spacing:0.4em; 
  color:rgba(255,255,255,0.2);
  text-transform:uppercase; 
  opacity:0; 
  animation:fi 1.2s ease 0.5s forwards;
  text-align:center;
}
#cal-bar-wrap { 
  width:min(200px,60vw); 
  height:1px; 
  background:rgba(255,255,255,0.05); 
  overflow:hidden; 
  opacity:0; 
  animation:fi 0.5s ease 0.9s forwards; 
}
#cal-bar { 
  height:100%; 
  width:0%; 
  background:var(--gold); 
  transition:width 0.15s linear; 
}
#cal-sub { 
  font-size:clamp(8px,2.5vw,9px); 
  letter-spacing:0.3em; 
  color:rgba(255,255,255,0.12); 
  text-transform:uppercase; 
  opacity:0; 
  animation:fi 0.5s ease 1.1s forwards;
  text-align:center;
  max-width:80vw;
}
@keyframes fi { to { opacity:1; } }

/* DEMO STEPS */
#demo-flow { 
  position:fixed; 
  top:0; 
  left:0; 
  right:0; 
  bottom:0; 
  z-index:5; 
  pointer-events:none; 
  display:flex; 
  flex-direction:column; 
  align-items:center; 
  justify-content:center; 
  gap:10px; 
}
.dstep { 
  font-family:'Cormorant Garamond',serif; 
  font-style:italic; 
  font-size:clamp(13px,4vw,15px); 
  color:rgba(200,168,75,0); 
  letter-spacing:0.1em; 
  transition:color 1.2s; 
  text-align:center; 
  padding:0 32px; 
  max-width:90vw;
}
.dstep.on { 
  color:rgba(200,168,75,0.5); 
}

/* REGIME MESSAGE */
#regime-msg {
  position:fixed;
  bottom:45%;
  left:50%; 
  transform:translateX(-50%);
  z-index:6; 
  font-family:'Cormorant Garamond',serif; 
  font-style:italic;
  font-size:clamp(12px,4vw,13px); 
  color:var(--gold); 
  opacity:0; 
  white-space:nowrap;
  letter-spacing:0.08em; 
  pointer-events:none; 
  transition:opacity 0.8s;
}

/* REPLAY */
#replay {
  position:fixed; 
  bottom:0; 
  left:0; 
  right:0; 
  z-index:8;
  background:rgba(8,8,8,0.98); 
  border-top:1px solid rgba(255,255,255,0.06);
  padding:14px 24px 20px; 
  transform:translateY(100%); 
  transition:transform 0.5s ease;
  backdrop-filter:blur(10px);
  -webkit-backdrop-filter:blur(10px);
  padding-bottom:calc(20px + var(--safe-bottom));
}
#replay.on { 
  transform:translateY(0); 
}
#replay-title { 
  font-size:8px; 
  letter-spacing:0.35em; 
  color:rgba(255,255,255,0.2); 
  text-transform:uppercase; 
  margin-bottom:9px; 
}
#replay-canvas { 
  width:100%; 
  height:30px; 
  display:block; 
}
#replay-close { 
  position:absolute; 
  top:12px; 
  right:20px; 
  font-size:9px; 
  letter-spacing:0.3em; 
  color:rgba(255,255,255,0.2); 
  cursor:pointer; 
  text-transform:uppercase;
  padding:8px;
}

/* RIPPLE */
.ripple {
  position:fixed; 
  border-radius:50%;
  border:1px solid rgba(200,168,75,0.3); 
  pointer-events:none; 
  z-index:20;
  animation:rp 0.8s ease forwards;
}
@keyframes rp {
  from { width:0; height:0; opacity:0.6; margin:0; }
  to { width:min(60px,15vw); height:min(60px,15vw); opacity:0; margin:calc(-1 * min(30px,7.5vw)); }
}
</style>
</head>
<body>

<div id="calibrating">
  <div id="cal-phi">φ</div>
  <div id="cal-text">coherence monitor</div>
  <div id="cal-bar-wrap"><div id="cal-bar"></div></div>
  <div id="cal-sub">touch anywhere to begin</div>
</div>

<div id="touch-hint">touch · scroll · type</div>

<div id="app" style="opacity:0;transition:opacity 1.5s;">
  <canvas id="bg-canvas"></canvas>

  <div id="top">
    <div id="phi-mark">φ-core</div>
    <div id="time-display">
      <span id="sess-time">00:00</span><br>
      <span id="ev-count" style="opacity:0.4">—</span>
    </div>
  </div>

  <div id="centre">
    <div id="ring-wrap">
      <canvas id="ring-canvas"></canvas>
      <div id="centre-text">
        <div id="regime-word">—</div>
        <div id="cv-num">CV —</div>
        <div id="persist-line">persist —</div>
      </div>
    </div>
  </div>

  <div id="bottom">
    <div id="trace-wrap">
      <span id="trace-label">signal</span>
      <canvas id="trace-canvas"></canvas>
    </div>

    <div id="ternary-bar"></div>

    <div style="margin-bottom:10px;">
      <div id="band-label">coherence band</div>
      <div id="band-track"><div id="band-fill"></div></div>
      <div id="band-ticks"></div>
    </div>

    <div id="stats">
      <div class="sc"><span class="sn">cv</span><span class="sv" id="s-cv">—</span></div>
      <div class="sc"><span class="sn">persist</span><span class="sv" id="s-persist">—</span></div>
      <div class="sc"><span class="sn">regime</span><span class="sv" id="s-regime">—</span></div>
    </div>

    <div id="meta-line"></div>
    <div id="trans-line"></div>

    <div id="type-wrap">
      <span id="type-label">type anything — cadence is the signal</span>
      <input id="type-input" type="text" placeholder="…" autocomplete="off" autocorrect="off" spellcheck="false" inputmode="text">
    </div>

    <button id="export-btn">⬇ export proof · json</button>
    <div id="prompt">touch · scroll · type · breathe</div>
  </div>
</div>

<div id="demo-flow">
  <div class="dstep" id="ds1">open · begin using your phone normally</div>
  <div class="dstep" id="ds2">touch · scroll · type · the signal reads itself</div>
  <div class="dstep" id="ds3">watch the ring · it knows where you are</div>
</div>

<div id="regime-msg"></div>

<div id="replay">
  <div id="replay-title">last 30 seconds</div>
  <canvas id="replay-canvas"></canvas>
  <div id="replay-close" onclick="closeReplay()">close</div>
</div>

<script>
// ─── CONSTANTS ───────────────────────────────────────────────────────────────
const PHI = 1.6180339887;
const TAU = Math.PI * 2;

const PHI_LEVELS = [
  { cv:0.39,  label:'1/256'    },
  { cv:3.82,  label:'1/φ²×10' },
  { cv:6.18,  label:'1/φ×10'  },
  { cv:15.0,  label:'edge'    },
  { cv:38.2,  label:'1/φ²×100'},
  { cv:61.8,  label:'1/φ×100' },
  { cv:100.0, label:'random'  },
];

const REGIMES = {
  LOCK:   { word:'constrained', color:'#8b3a2a' },
  RIBBON: { word:'coherent',    color:'#c8a84b' },
  EDGE:   { word:'shifting',    color:'#8b5a2a' },
  NOISE:  { word:'open',        color:'#2a4a7a' },
  BREATHING: { word:'coherent · breathing', color:'#d4b87a' },
};

const REGIME_MSGS = {
  RIBBON: ['coherence holding','in the band','structure present','baseline stable'],
  BREATHING: ['flexible coherence','rhythmic and open','stable but breathing','alive in the band'],
  EDGE:   ['shifting from centre','band boundary near','something changing','notice this'],
  LOCK:   ['over-constrained','rigidity present','the band has two edges','breathe'],
  NOISE:  ['structure diffuse','open field','low coherence','return when ready'],
};

// ─── STATE ───────────────────────────────────────────────────────────────────
const S = {
  itvBuf:    [],
  ternBuf:   [],
  sigBuf:    new Array(200).fill(0),
  touchTimes:[],
  cv:        0,
  persist:   0,
  alternation:0,
  zeroDensity:0,
  ternaryEntropy:0,
  regime:    'RIBBON',
  displayRegime: 'RIBBON',
  prevRegime:null,
  lastTransitionTime: null,
  startTime: Date.now(),
  eventCount:0,
  calibrated:false,
  calProgress:0,
  ringAngle: 0,
  breathPhase:0,
  motionEnabled: false,
  syntheticSeed: false,
};

const baseline = { snaps:[], established:false, meanCV:null, stdCV:null };
const transitions = [];
const replayBuf = [];
let lastRegimeMsgTime = 0;
let lastKeyTime = 0;

// ─── DOM REFS ─────────────────────────────────────────────────────────────────
const appEl    = document.getElementById('app');
const calEl    = document.getElementById('calibrating');
const calBar   = document.getElementById('cal-bar');
const bgCanvas = document.getElementById('bg-canvas');
const ringCanvas = document.getElementById('ring-canvas');
const traceCanvas= document.getElementById('trace-canvas');
const bgCtx    = bgCanvas.getContext('2d');
const ringCtx  = ringCanvas.getContext('2d');
const traceCtx = traceCanvas.getContext('2d');
const touchHint = document.getElementById('touch-hint');

// ─── SETUP ───────────────────────────────────────────────────────────────────
function setupCanvases() {
  const dpr = window.devicePixelRatio || 1;
  
  bgCanvas.width  = window.innerWidth  * dpr;
  bgCanvas.height = window.innerHeight * dpr;
  bgCanvas.style.width  = window.innerWidth  + 'px';
  bgCanvas.style.height = window.innerHeight + 'px';
  bgCtx.scale(dpr, dpr);

  const ringWrap = document.getElementById('ring-wrap');
  if (ringWrap) {
    const rs = ringWrap.offsetWidth;
    ringCanvas.width  = rs * dpr;
    ringCanvas.height = rs * dpr;
    ringCanvas.style.width  = rs + 'px';
    ringCanvas.style.height = rs + 'px';
    ringCtx.scale(dpr, dpr);
  }

  const traceWrap = document.getElementById('trace-wrap');
  if (traceWrap) {
    const tw = traceWrap.offsetWidth;
    const th = traceWrap.offsetHeight;
    traceCanvas.width  = tw * dpr;
    traceCanvas.height = th * dpr;
    traceCanvas.style.width  = '100%';
    traceCanvas.style.height = '100%';
    traceCtx.scale(dpr, dpr);
  }
}

function buildBandTicks() {
  const el = document.getElementById('band-ticks');
  if (!el) return;
  el.innerHTML = '';
  PHI_LEVELS.forEach(l => {
    const pct = Math.min(l.cv, 100);
    const tick = document.createElement('div');
    tick.className = 'btick';
    tick.style.left = pct + '%';
    el.appendChild(tick);
    const lbl = document.createElement('div');
    lbl.className = 'blabel';
    lbl.style.left = pct + '%';
    lbl.textContent = l.label;
    el.appendChild(lbl);
  });
}

function buildTernBar() {
  const el = document.getElementById('ternary-bar');
  if (!el) return;
  el.innerHTML = '';
  for (let i = 0; i < 48; i++) {
    const d = document.createElement('div');
    d.className = 'tseg';
    el.appendChild(d);
  }
}

// ─── ENTROPY CALCULATION (new for v5) ────────────────────────────────────────
function calculateTernaryEntropy(ternaryArray) {
  if (!ternaryArray || ternaryArray.length < 10) return 0;
  
  const counts = { '-1': 0, '0': 0, '1': 0 };
  ternaryArray.forEach(v => counts[v]++);
  
  let entropy = 0;
  const len = ternaryArray.length;
  
  Object.values(counts).forEach(count => {
    if (count > 0) {
      const p = count / len;
      entropy -= p * Math.log2(p);
    }
  });
  
  // Normalize to max possible entropy (log2(3) ≈ 1.585)
  return entropy / Math.log2(3);
}

// ─── MOTION PERMISSION (iOS) ─────────────────────────────────────────────────
function setupMotionPermission() {
  if (typeof DeviceMotionEvent !== "undefined" && 
      typeof DeviceMotionEvent.requestPermission === "function") {
    
    const permissionBtn = document.createElement("button");
    permissionBtn.id = "motion-permission";
    permissionBtn.innerText = "⟳ enable motion sensing";
    
    permissionBtn.onclick = async () => {
      try {
        const permission = await DeviceMotionEvent.requestPermission();
        if (permission === "granted") {
          window.addEventListener('devicemotion', handleDeviceMotion, { passive: true });
          permissionBtn.remove();
          S.motionEnabled = true;
          showTouchHint('motion enabled', 2000);
        }
      } catch (error) {
        console.log('Motion permission error:', error);
      }
    };
    
    document.body.appendChild(permissionBtn);
  } else {
    if (window.DeviceMotionEvent) {
      window.addEventListener('devicemotion', handleDeviceMotion, { passive: true });
      S.motionEnabled = true;
    }
  }
}

function handleDeviceMotion(e) {
  if (e.accelerationIncludingGravity) {
    recordItv(Date.now());
  }
}

// ─── EVENT CAPTURE ───────────────────────────────────────────────────────────
function recordItv(t) {
  if (S.touchTimes.length > 0) {
    const itv = t - S.touchTimes[S.touchTimes.length - 1];
    if (itv > 10 && itv < 30000) {
      S.itvBuf.push(itv);
      if (S.itvBuf.length > 256) S.itvBuf.shift();
    }
  }
  S.touchTimes.push(t);
  if (S.touchTimes.length > 300) S.touchTimes.shift();
  S.eventCount++;
  
  if (S.eventCount === 1 && touchHint) {
    touchHint.style.opacity = '0';
  }
}

function ripple(x, y) {
  const r = document.createElement('div');
  r.className = 'ripple';
  r.style.left = x + 'px';
  r.style.top  = y + 'px';
  document.body.appendChild(r);
  setTimeout(() => r.remove(), 900);
}

function showTouchHint(text, duration) {
  if (!touchHint) return;
  touchHint.textContent = text;
  touchHint.style.opacity = '1';
  setTimeout(() => {
    touchHint.style.opacity = '0';
  }, duration);
}

document.addEventListener('touchstart', e => {
  const t = e.touches[0];
  recordItv(Date.now());
  ripple(t.clientX, t.clientY);
}, { passive: true });

document.addEventListener('touchmove', () => recordItv(Date.now()), { passive: true });
document.addEventListener('touchend',  () => recordItv(Date.now()), { passive: true });

document.addEventListener('mousedown', e => { 
  recordItv(Date.now()); 
  ripple(e.clientX, e.clientY); 
});

document.addEventListener('mousemove', e => { 
  if (e.buttons) recordItv(Date.now()); 
});

document.addEventListener('visibilitychange', () => recordItv(Date.now()));

const typeInput = document.getElementById('type-input');
if (typeInput) {
  typeInput.addEventListener('keydown', () => {
    const now = Date.now();
    if (lastKeyTime > 0) {
      const itv = now - lastKeyTime;
      if (itv > 20 && itv < 5000) {
        S.itvBuf.push(itv);
        if (S.itvBuf.length > 256) S.itvBuf.shift();
        S.eventCount++;
      }
    }
    lastKeyTime = now;
    recordItv(now);
  });
}

// ─── φ-CORE ENGINE ───────────────────────────────────────────────────────────
function runEngine() {
  const buf = S.itvBuf;
  if (buf.length < 8) return;

  const mean = buf.reduce((a,b) => a+b, 0) / buf.length;
  const variance = buf.reduce((a,b) => a+(b-mean)*(b-mean), 0) / buf.length;
  const std = Math.sqrt(variance);
  S.cv = mean > 0 ? (std / mean) * 100 : 50;

  S.sigBuf = buf.slice(-200).map(v => (v - mean) / (std + 1));

  const thresh = mean * 0.05;
  const tern = [];
  for (let i = 1; i < buf.length; i++) {
    const d = buf[i] - buf[i-1];
    tern.push(d > thresh ? 1 : d < -thresh ? -1 : 0);
  }
  S.ternBuf = tern.slice(-48);

  let persist = 0, pCount = 0;
  for (let i = 1; i < tern.length; i++) {
    if (tern[i-1] !== 0) {
      pCount++;
      if (tern[i] === tern[i-1]) persist++;
    }
  }
  S.persist = pCount > 0 ? persist / pCount : 0.5;

  let alt = 0, aCount = 0;
  for (let i = 2; i < tern.length; i++) {
    if (tern[i-1] !== 0 && tern[i-2] !== 0) {
      aCount++;
      if (tern[i] !== tern[i-1]) alt++;
    }
  }
  S.alternation = aCount > 0 ? alt / aCount : 0.5;

  const zeros = tern.filter(v => v === 0).length;
  S.zeroDensity = tern.length > 0 ? zeros / tern.length : 0;
  
  // Calculate ternary entropy (new for v5)
  S.ternaryEntropy = calculateTernaryEntropy(tern.slice(-32));

  // Regime classification
  S.prevRegime = S.displayRegime;
  
  let baseRegime;
  if (S.cv < 2) baseRegime = 'LOCK';
  else if (S.cv < 20) baseRegime = 'RIBBON';
  else if (S.cv < 50) baseRegime = 'EDGE';
  else baseRegime = 'NOISE';
  
  // Check for breathing mode (coherent + high entropy)
  if (baseRegime === 'RIBBON' && S.ternaryEntropy > 0.85) {
    S.displayRegime = 'BREATHING';
  } else {
    S.displayRegime = baseRegime;
  }

  if (S.displayRegime !== S.prevRegime) {
    S.lastTransitionTime = Date.now();
    transitions.push({
      elapsed_ms: Date.now() - S.startTime,
      from: S.prevRegime,
      to: S.displayRegime,
      cv: parseFloat(S.cv.toFixed(2)),
      persist: parseFloat(S.persist.toFixed(3)),
    });
  }

  S.calProgress = Math.min(buf.length / 24, 1);
  if (buf.length >= 24 && !S.calibrated) {
    S.calibrated = true;
    calEl.style.opacity = '0';
    setTimeout(() => { 
      calEl.style.display = 'none'; 
      if (touchHint) touchHint.style.opacity = '0.6';
    }, 1500);
    appEl.style.opacity = '1';
  }
}

// ─── SYNTHETIC SEED ─────────────────────────────────────────────────
function seedSyntheticIntervals() {
  if (S.itvBuf.length < 4 && !S.syntheticSeed) {
    S.syntheticSeed = true;
    const base = 600 + Math.random() * 200;
    for (let i = 0; i < 16; i++) {
      S.itvBuf.push(base + (Math.random() - 0.5) * base * 0.15);
    }
    showTouchHint('demo mode · touch to begin', 3000);
  }
}

// ─── SELF-BASELINE ───────────────────────────────────────────────────────────
function updateBaseline() {
  if (!S.calibrated) return;
  const now = Date.now();
  baseline.snaps.push({ t: now, cv: S.cv });
  baseline.snaps = baseline.snaps.filter(s => s.t > now - 300000);
  if (baseline.snaps.length >= 10) {
    const cvs = baseline.snaps.map(s => s.cv);
    baseline.meanCV = cvs.reduce((a,b) => a+b,0) / cvs.length;
    const v = cvs.reduce((a,b) => a+(b-baseline.meanCV)*(b-baseline.meanCV), 0) / cvs.length;
    baseline.stdCV = Math.sqrt(v);
    baseline.established = true;
  }
}

// ─── REPLAY ─────────────────────────────────────────────────────────────────
function updateReplay() {
  const now = Date.now();
  replayBuf.push({ t: now, cv: S.cv, regime: S.displayRegime, persist: S.persist });
  while (replayBuf.length > 0 && replayBuf[0].t < now - 30000) replayBuf.shift();
}

function drawReplayStrip() {
  const canvas = document.getElementById('replay-canvas');
  if (!canvas) return;
  const dpr = window.devicePixelRatio || 1;
  const W = canvas.parentElement.offsetWidth - 16;
  const H = 30;
  canvas.width  = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width  = W + 'px';
  canvas.style.height = H + 'px';
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  ctx.clearRect(0, 0, W, H);
  if (replayBuf.length < 2) return;
  const oldest = replayBuf[0].t;
  const span = (replayBuf[replayBuf.length-1].t - oldest) || 1;
  let lastR = null;
  replayBuf.forEach((snap, i) => {
    const x = ((snap.t - oldest) / span) * W;
    const nx = replayBuf[i+1] ? ((replayBuf[i+1].t - oldest) / span) * W : W;
    const w = Math.max(1, nx - x);
    const col = REGIMES[snap.regime]?.color || REGIMES.RIBBON.color;
    ctx.fillStyle = col;
    ctx.globalAlpha = 0.35;
    ctx.fillRect(x, H * 0.65, w, H * 0.35);
    const cy = H * 0.65 - (Math.min(snap.cv, 100) / 100) * H * 0.55;
    ctx.globalAlpha = 0.75;
    ctx.fillRect(x, cy, Math.max(1, w * 0.7), 1.5);
    if (snap.regime !== lastR) {
      ctx.globalAlpha = 0.5;
      ctx.font = '7px DM Mono,monospace';
      ctx.fillStyle = col;
      const label = (snap.regime === 'BREATHING') ? 'breath' : (REGIMES[snap.regime]?.word.slice(0,5) || snap.regime.slice(0,5));
      ctx.fillText(label, Math.min(x+1, W-36), 9);
      lastR = snap.regime;
    }
  });
  ctx.globalAlpha = 1;
}

function showReplay() { 
  drawReplayStrip(); 
  document.getElementById('replay').classList.add('on'); 
}
function closeReplay() { 
  document.getElementById('replay').classList.remove('on'); 
}

let pressTimer = null;
document.addEventListener('touchstart', () => { 
  pressTimer = setTimeout(showReplay, 800); 
}, { passive: true });
document.addEventListener('touchend',   () => { 
  if (pressTimer) clearTimeout(pressTimer); 
}, { passive: true });

// ─── EXPORT ─────────────────────────────────────────────────────────────────
document.getElementById('export-btn').addEventListener('click', () => {
  const itv = S.itvBuf.slice(-128);
  const mean = itv.length ? itv.reduce((a,b)=>a+b,0)/itv.length : null;
  const std  = mean ? Math.sqrt(itv.reduce((a,b)=>a+(b-mean)*(b-mean),0)/itv.length) : null;
  const proof = {
    meta: { version:'phi-core-v5-breathing', exported_at:new Date().toISOString(), session_ms:Date.now()-S.startTime, events:S.eventCount },
    threshold_constants: {
      phi:1.6180339887,
      level_seam:0.39, level_tide:3.82, level_heart:6.18,
      level_edge:15.0, level_complex:38.2, level_sunspot:61.8, level_random:100.0,
    },
    window_parameters: {
      ternary_threshold_fraction:0.05, min_events_calibration:24,
      interval_min_ms:10, interval_max_ms:30000, baseline_window_ms:300000,
    },
    baseline_snapshot: {
      established:baseline.established,
      mean_cv: baseline.meanCV ? +baseline.meanCV.toFixed(3) : null,
      std_cv:  baseline.stdCV  ? +baseline.stdCV.toFixed(3)  : null,
      sample_count: baseline.snaps.length,
    },
    current_state: {
      cv:+S.cv.toFixed(3), persist:+S.persist.toFixed(3),
      alternation:+S.alternation.toFixed(3), zero_density:+S.zeroDensity.toFixed(3),
      ternary_entropy:+S.ternaryEntropy.toFixed(3),
      regime:S.displayRegime, base_regime:S.regime,
      ternary_last_32:S.ternBuf.slice(-32),
    },
    interval_stats: {
      count:itv.length,
      mean_ms:  mean ? +mean.toFixed(1)  : null,
      std_ms:   std  ? +std.toFixed(1)   : null,
      cv_pct:   +S.cv.toFixed(3),
    },
    raw_intervals_ms: itv,
    transitions,
    replay_30s: replayBuf.map(s => ({
      elapsed_ms: s.t - S.startTime,
      cv: +s.cv.toFixed(2), regime: s.regime, persist: +s.persist.toFixed(3),
    })),
  };
  const blob = new Blob([JSON.stringify(proof, null, 2)], { type:'application/json' });
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement('a');
  a.href     = url;
  a.download = 'phi-coherence-' + Date.now() + '.json';
  a.click();
  URL.revokeObjectURL(url);
});

// ─── DRAW RING ────────────────────────────────────────────────────────────────
function drawRing() {
  const W = ringCanvas.offsetWidth;
  const H = ringCanvas.offsetHeight;
  if (!W || !H) return;
  const CX = W/2, CY = H/2;
  const R  = Math.min(W,H) * 0.44;
  const ctx = ringCtx;
  ctx.clearRect(0, 0, W, H);

  const reg = REGIMES[S.displayRegime] || REGIMES.RIBBON;
  S.breathPhase += S.displayRegime === 'BREATHING' ? 0.018 : 0.012; // Faster breath in breathing mode
  const breath = Math.sin(S.breathPhase) * 0.5 + 0.5;

  PHI_LEVELS.forEach(l => {
    const r = (Math.min(l.cv,100) / 100) * R;
    const isNear = Math.abs(S.cv - l.cv) < 8;
    ctx.beginPath();
    ctx.arc(CX, CY, r, 0, TAU);
    ctx.strokeStyle = isNear ? 'rgba(200,168,75,0.22)' : 'rgba(255,255,255,0.04)';
    ctx.lineWidth   = isNear ? 1 : 0.5;
    ctx.stroke();
  });

  ctx.beginPath();
  for (let a = 0; a < TAU * 3; a += 0.04) {
    const r = (a / (TAU*3)) * R * 0.35;
    const sx = CX + r * Math.cos(a + S.ringAngle * 0.2);
    const sy = CY + r * Math.sin(a + S.ringAngle * 0.2);
    a < 0.04 ? ctx.moveTo(sx,sy) : ctx.lineTo(sx,sy);
  }
  ctx.strokeStyle = 'rgba(200,168,75,0.05)';
  ctx.lineWidth = 0.5;
  ctx.stroke();

  const arcR = R * 0.88;
  ctx.beginPath();
  ctx.arc(CX, CY, arcR, 0, TAU);
  ctx.strokeStyle = 'rgba(255,255,255,0.04)';
  ctx.lineWidth = 3;
  ctx.stroke();

  const arcSpan = TAU * S.persist;
  const startA  = -TAU/4 + S.ringAngle;
  ctx.beginPath();
  ctx.arc(CX, CY, arcR, startA, startA + arcSpan);
  ctx.strokeStyle = reg.color;
  // Wider line in breathing mode
  ctx.lineWidth   = (S.displayRegime === 'BREATHING' ? 2.5 : 2) + breath * (S.displayRegime === 'BREATHING' ? 2.5 : 1.5);
  ctx.lineCap     = 'round';
  ctx.globalAlpha = 0.65 + breath * 0.3;
  ctx.stroke();
  ctx.globalAlpha = 1;

  const dotA = startA + (Math.min(S.cv,100)/100) * TAU;
  ctx.beginPath();
  ctx.arc(CX + arcR * Math.cos(dotA), CY + arcR * Math.sin(dotA), (S.displayRegime === 'BREATHING' ? 5 : 4) + breath*2, 0, TAU);
  ctx.fillStyle   = reg.color;
  ctx.globalAlpha = 0.9;
  ctx.fill();
  ctx.globalAlpha = 1;

  ctx.save();
  ctx.globalAlpha = 0.04 + breath * 0.04;
  ctx.fillStyle   = reg.color;
  ctx.beginPath();
  ctx.arc(CX, CY, R * 0.3, 0, TAU);
  ctx.fill();
  ctx.restore();

  const ternR = R * 0.6;
  S.ternBuf.forEach((v, i) => {
    const fade  = i / S.ternBuf.length;
    const angle = (i / S.ternBuf.length) * TAU - TAU/4 + S.ringAngle * 0.3;
    const x = CX + ternR * Math.cos(angle);
    const y = CY + ternR * Math.sin(angle);
    ctx.beginPath();
    ctx.arc(x, y, 1.5 + fade, 0, TAU);
    if (v === 1)       ctx.fillStyle = `rgba(80,160,80,${0.5*fade})`;
    else if (v === -1) ctx.fillStyle = `rgba(180,70,50,${0.5*fade})`;
    else               ctx.fillStyle = `rgba(70,110,50,${0.6*fade})`;
    ctx.fill();
  });

  S.ringAngle += 0.003;
}

// ─── DRAW TRACE ───────────────────────────────────────────────────────────────
function drawTrace() {
  const W = traceCanvas.offsetWidth;
  const H = traceCanvas.offsetHeight;
  if (!W || !H) return;
  const ctx = traceCtx;
  ctx.clearRect(0, 0, W, H);
  const buf = S.sigBuf;
  if (buf.length < 2) return;
  const step = W / buf.length;
  const reg  = REGIMES[S.displayRegime] || REGIMES.RIBBON;

  const tern = S.ternBuf;
  const ts   = W / Math.min(tern.length, buf.length);
  const off  = Math.max(0, tern.length - buf.length);
  for (let i = 0; i < Math.min(tern.length, buf.length); i++) {
    const v = tern[i+off] || 0;
    ctx.fillStyle = v === 1 ? 'rgba(80,160,80,0.07)' : v === -1 ? 'rgba(180,70,50,0.07)' : 'rgba(70,110,50,0.12)';
    ctx.fillRect(i*ts, 0, ts+1, H);
  }

  ctx.beginPath();
  ctx.moveTo(0, H/2); ctx.lineTo(W, H/2);
  ctx.strokeStyle = 'rgba(255,255,255,0.07)';
  ctx.lineWidth   = 0.5;
  ctx.stroke();

  ctx.beginPath();
  buf.forEach((v, i) => {
    const x = i * step;
    const y = H/2 - Math.max(-1, Math.min(1,v)) * H * 0.38;
    i === 0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
  });
  ctx.strokeStyle = reg.color;
  ctx.lineWidth   = 1;
  ctx.globalAlpha = 0.6;
  ctx.stroke();
  ctx.globalAlpha = 1;
}

// ─── DRAW BACKGROUND ─────────────────────────────────────────────────────────
function drawBg() {
  const W = window.innerWidth, H = window.innerHeight;
  bgCtx.fillStyle = 'rgba(8,8,8,0.06)';
  bgCtx.fillRect(0, 0, W, H);
  const vign = bgCtx.createRadialGradient(W/2, H/2, H*0.2, W/2, H/2, H*0.8);
  vign.addColorStop(0,'rgba(0,0,0,0)');
  vign.addColorStop(1,'rgba(0,0,0,0.45)');
  bgCtx.fillStyle = vign;
  bgCtx.fillRect(0, 0, W, H);
}

// ─── UPDATE UI ────────────────────────────────────────────────────────────────
function updateUI() {
  const reg = REGIMES[S.displayRegime] || REGIMES.RIBBON;
  const el  = id => document.getElementById(id);

  const regimeWord = el('regime-word');
  if (regimeWord) {
    regimeWord.textContent = reg.word;
    regimeWord.style.color = reg.color;
  }
  
  const cvNum = el('cv-num');
  if (cvNum) cvNum.textContent = 'CV ' + S.cv.toFixed(1) + '%';

  const persistLine = el('persist-line');
  if (persistLine) {
    const poised = S.zeroDensity > 0.4 && S.displayRegime === 'RIBBON' ? 'poised · ' : 
                   S.displayRegime === 'BREATHING' ? 'breathing · ' : '';
    persistLine.textContent = poised + 'persist ' + (S.persist*100).toFixed(0) + '%';
  }

  const sCv = el('s-cv');
  if (sCv) {
    sCv.textContent = S.cv.toFixed(1) + '%';
    sCv.style.color = reg.color;
  }
  
  const sPersist = el('s-persist');
  if (sPersist) sPersist.textContent = (S.persist*100).toFixed(0) + '%';
  
  const sRegime = el('s-regime');
  if (sRegime) {
    sRegime.textContent = S.displayRegime === 'BREATHING' ? 'breathing' : S.displayRegime;
    sRegime.style.color = reg.color;
  }

  const meta = el('meta-line');
  if (meta) {
    if (baseline.established) {
      meta.textContent = 'your baseline  ' + baseline.meanCV.toFixed(1) + '%';
      meta.style.opacity = '0.5';
    } else {
      meta.textContent = 'calibrating  ' + Math.round(S.calProgress*100) + '%';
      meta.style.opacity = '0.2';
    }
  }

  const trans = el('trans-line');
  if (trans) {
    if (S.lastTransitionTime) {
      const ago = Math.round((Date.now() - S.lastTransitionTime) / 1000);
      trans.textContent = ago < 3600 ? 'last shift  ' + ago + 's ago' : '';
      trans.style.opacity = '0.3';
    }
  }

  const bandFill = el('band-fill');
  if (bandFill) {
    bandFill.style.width = Math.min(S.cv,100) + '%';
    bandFill.style.background = reg.color;
  }

  const elapsed = Math.floor((Date.now()-S.startTime)/1000);
  const sessTime = el('sess-time');
  if (sessTime) {
    sessTime.textContent = String(Math.floor(elapsed/60)).padStart(2,'0') + ':' + String(elapsed%60).padStart(2,'0');
  }
  
  const evCount = el('ev-count');
  if (evCount) evCount.textContent = S.eventCount + ' events';

  if (!S.calibrated && calBar) calBar.style.width = (S.calProgress*100) + '%';

  if (S.displayRegime !== S.prevRegime && S.calibrated) {
    const now = Date.now();
    if (now - lastRegimeMsgTime > 6000) {
      lastRegimeMsgTime = now;
      const msgs = REGIME_MSGS[S.displayRegime] || REGIME_MSGS.RIBBON;
      const msg  = msgs[Math.floor(Math.random()*msgs.length)];
      const el2  = document.getElementById('regime-msg');
      if (el2) {
        el2.textContent = msg;
        el2.style.opacity = '0.7';
        setTimeout(() => { el2.style.opacity = '0'; }, 3000);
      }
    }
  }

  const segs = document.querySelectorAll('.tseg');
  const tern = S.ternBuf.slice(-48);
  segs.forEach((seg, i) => {
    const v = tern[i] !== undefined ? tern[i] : null;
    if (v === null) { seg.style.background = 'rgba(255,255,255,0.03)'; return; }
    const fade = i / 48;
    if (v === 1)       seg.style.background = `rgba(80,160,80,${0.15+fade*0.35})`;
    else if (v === -1) seg.style.background = `rgba(180,70,50,${0.15+fade*0.35})`;
    else               seg.style.background = `rgba(70,110,50,${0.2+fade*0.3})`;
  });

  const prompt = el('prompt');
  if (prompt && S.eventCount > 5) prompt.style.opacity = '0';
}

// ─── DEMO FLOW ────────────────────────────────────────────────────────────────
function runDemoFlow() {
  [
    { id:'ds1', show:600,   hide:10000 },
    { id:'ds2', show:5000,  hide:18000 },
    { id:'ds3', show:13000, hide:26000 },
  ].forEach(s => {
    setTimeout(() => {
      const el = document.getElementById(s.id);
      if (el) el.classList.add('on');
    }, s.show);
    setTimeout(() => {
      const el = document.getElementById(s.id);
      if (el) el.classList.remove('on');
    }, s.hide);
  });
  setTimeout(() => { if (S.calibrated) showReplay(); }, 120000);
}

// ─── MAIN LOOP ────────────────────────────────────────────────────────────────
let frame = 0;
let lastEngineTime = 0;

function loop(t) {
  requestAnimationFrame(loop);
  frame++;

  if (t - lastEngineTime > 500) {
    runEngine();
    updateBaseline();
    updateReplay();
    lastEngineTime = t;
  }

  drawBg();
  drawRing();
  drawTrace();

  if (frame % 5 === 0) updateUI();
}

// ─── INIT ─────────────────────────────────────────────────────────────────────
function init() {
  setupCanvases();
  buildBandTicks();
  buildTernBar();

  bgCtx.fillStyle = '#080808';
  bgCtx.fillRect(0, 0, window.innerWidth, window.innerHeight);

  setupMotionPermission();

  setTimeout(seedSyntheticIntervals, 2000);

  setTimeout(() => {
    if (!S.calibrated && touchHint) {
      touchHint.style.opacity = '0.6';
    }
  }, 3000);

  runDemoFlow();
  requestAnimationFrame(loop);
}

window.addEventListener('resize', () => {
  setupCanvases();
  bgCtx.fillStyle = '#080808';
  bgCtx.fillRect(0, 0, window.innerWidth, window.innerHeight);
});

init();
</script>
</body>
</html>
